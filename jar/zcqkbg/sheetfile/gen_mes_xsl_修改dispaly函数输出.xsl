<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<!--
!! FILE:        $JXSL/gen_mes_xsl.xsl
!! DESCRIPTION: This stylesheet is designed to take the XML output of the MFP
!!              program and create an indidvidual stylesheet for each message
!!              number. The resultant stylesheets can then be combined with an
!!              XML message generated by the CEP to create a viewable message.
!!              The format of the MFP XML output is documented with that
!!              program.
-->
	<xsl:import href="file:/D:/bgxt-wxy/xsl/utm.xsl"/>
	<xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes"/>
	<xsl:param name="language" select="'english'"/>
	<xsl:param name="gdata" select="'file:/D:/bgxt-wxy/mdf--xlst/home/jtlsdev/game/data'"/>
	<xsl:param name="header" select="''"/>
	<xsl:variable name="mes-root" select="concat($gdata,'/messages/mes_xsl/languages/',$language)"/>
	<xsl:variable name="header-root" select="concat($gdata,'/messages/mes_xsl/headers')"/>
	<xsl:variable name="shelf-life-file" select="concat($gdata,'/messages/msg_shelf_life.xml')"/>
	<xsl:variable name="cr">
		<xsl:text>
</xsl:text>
	</xsl:variable>
	<xsl:variable name="newline">
		<xsl:text>
</xsl:text>
	</xsl:variable>
	<xsl:variable name="apos">
		<xsl:text>'</xsl:text>
	</xsl:variable>
	<!--
!! TEMPLATE:    match /header-footer
!! DESCRIPTION: This template is the main driver for a header/footer file.
!!              There is one header-footer section which is converted into
!!              an XSL file.
-->
	<xsl:template match="/header-footer">
		<xsl:variable name="header-file" select="concat($header-root,'/',$header,'.xsl')"/>
		<xsl:result-document method="xml" href="{$header-file}">
			<xsl:call-template name="make-header-template"/>
		</xsl:result-document>
	</xsl:template>
	<!-- match /header-footer -->
	<!--
!! TEMPLATE:    match /msgs
!! DESCRIPTION: This template is the main driver for a message definition file.
!!              There is one msgs section with a separate msg child tag for
!!              each message number. Each of these message numbers is converted
!!              into a separate XSL file.
-->
	<xsl:template match="/msgs">
		<!-- Ensure that each message within the current XML appears in the shelf-life
       file once and only once -->
		<xsl:variable name="shelf-life-doc" select="document($shelf-life-file)"/>
		<xsl:variable name="shelf-life-messages" select="$shelf-life-doc/message-shelf-life/shelf-life/message"/>
		<xsl:result-document method="xml" href="message_error.log">
			<xsl:for-each select="msg">
				<xsl:variable name="index" select="@index"/>
				<!-- verify that the message exists. -->
				<xsl:if test="count($shelf-life-messages[@number = $index]) = 0">
					<xsl:value-of select="concat('No shelf life for message ', $index, $cr)"/>
				</xsl:if>
				<!-- verify that the message exists once. -->
				<xsl:if test="count($shelf-life-messages[@number = $index]) > 1">
					<xsl:value-of select="concat('Multiple shelf life entries for message ', $index, $cr)"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:result-document>
		<!-- Write out the modifiers or the default values of the modifiers when they
       are not present to a separate stylesheet -->
		<!-- RICK - IT DOES NOT APPEAR THAT THE GENERATED FORMAT DEFAULT FILE IS USED
     ANYWHERE. THIS SHOULD BE REMOVED AFTER JTLS 4.1 IF WE HAVE FOUND NO
     PROBLEMS WITH HAVING IT COMMENTED OUT 
  <xsl:call-template name="write-default-formats">
    <xsl:with-param name="modifiers" select="/msgs/modifiers"/>
    <xsl:with-param name="filename" select="'default-msg-formats.xsl'"/>
  </xsl:call-template>
RICK - END OF OBSOLETE BLOCK -->
		<!-- For each message create a separate message stylesheet and subject
       stylesheet -->
		<xsl:for-each select="msg">
			<!-- Create the stylesheets. -->
			<xsl:variable name="message-file" select="concat($mes-root,'/messages/msg',@index,'.xsl')"/>
			<xsl:result-document method="xml" href="{$message-file}">
				<xsl:call-template name="make-message-template"/>
			</xsl:result-document>
			<!-- create the subject only stylesheet. -->
			<xsl:variable name="subject-file" select="concat($mes-root,'/subjects/sub',@index,'.xsl')"/>
			<xsl:result-document method="xml" href="{$subject-file}">
				<xsl:call-template name="make-subject-template"/>
			</xsl:result-document>
		</xsl:for-each>
		<!-- message -->
	</xsl:template>
	<!-- match /msgs -->
	<!-- RICK - this template is beleieved to be obsolete. It should be removed
     after JTLS 4.1 if we have discovered no problems with its absence -->
	<!--
!! TEMPLATE:    write-default-formats
!! DESCRIPTION: This template is designed to process message modifiers and
!!              output them as a stylesheet to a file.
!!       RICK - THIS OUTPUT IS DIRECTED TO THE $JGAME/data/messages/mes_xsl/
!!              languages/<LANGUAGE>/default-msg-formats.xsl FILE. BUT I DO
!!              NOT THINK THAT ANYONE USES THAT FILE. I BELIEVE IT IS REDUNDANT
!!              OR OBSOLETE.
!!
!! PARAMETERS:
!!   modifiers  The XPath of the modifiers
!!   filename   The name of the file to create
-->
	<!--
<xsl:template name="write-default-formats">
  <xsl:param name="modifiers"/>
  <xsl:param name="filename"/>

  <xsl:result-document method="xml" href="{$mes-root}/{$filename}">
    <xsl:element name="xsl:stylesheet">
      <xsl:attribute name="version">1.0</xsl:attribute>
-->
	<!-- Create a variable LOCATION_FORMAT_DEF which will be set to the
           value of the location-format modifier if it exists. Otherwise
           a default location format is assigned -->
	<!--
      <xsl:element name="xsl:variable">
        <xsl:attribute name="name">LOCATION_FORMAT_DEF</xsl:attribute>
        <xsl:element name="xsl:text">
           <xsl:choose>
             <xsl:when test="$modifiers/location-format/@value">
               <xsl:value-of select="$modifiers/location-format/@value"/>
             </xsl:when>
             <xsl:otherwise>
               <xsl:text>%-2.2D-%-2.2M-%04.1FS%N %-3.3d-%-2.2m-%04.1Fs%E</xsl:text>
             </xsl:otherwise>
          </xsl:choose>
        </xsl:element> -->
	<!-- xsl:text -->
	<!--
      </xsl:element> -->
	<!-- xsl:variable -->
	<!-- Create a variable DURATION_FORMAT_DEF which will be set to the
           value of the duration-format modifier if it exists. Otherwise
           a default duration format is assigned -->
	<!--
      <xsl:element name="xsl:variable">
        <xsl:attribute name="name">DURATION_FORMAT_DEF</xsl:attribute>
        <xsl:element name="xsl:text">
           <xsl:choose>
             <xsl:when test="$modifiers/duration-format/@value">
                 <xsl:value-of select="$modifiers/duration-format/@value"/>
             </xsl:when>
             <xsl:otherwise>
               <xsl:text>%-2.2dD %-2.2hH %-2.2mM</xsl:text>
             </xsl:otherwise>
          </xsl:choose>
        </xsl:element> -->
	<!-- xsl:text -->
	<!--
      </xsl:element> -->
	<!-- xsl:variable -->
	<!-- Create a variable GTIME_FORMAT_DEF which will be set to the
           value of the time-format modifier if it exists. Otherwise
           a default time format is assigned to represent game time -->
	<!--
      <xsl:element name="xsl:variable">
        <xsl:attribute name="name">GTIME_FORMAT_DEF</xsl:attribute>
        <xsl:element name="xsl:text">
           <xsl:choose>
             <xsl:when test="$modifiers/time-format/@value">
                 <xsl:value-of select="$modifiers/time-format/@value"/>
             </xsl:when>
             <xsl:otherwise>
               <xsl:text>%d%H%MZ%b%y</xsl:text>
             </xsl:otherwise>
          </xsl:choose>
        </xsl:element> -->
	<!-- xsl:text -->
	<!--
      </xsl:element> -->
	<!-- xsl:variable -->
	<!-- Create a variable CLOCK_FORMAT_DEF which will be set to the
           value of the time-format modifier if it exists. Otherwise
           a default time format is assigned to represent wallclock time -->
	<!--
      <xsl:element name="xsl:variable">
        <xsl:attribute name="name">CLOCK_FORMAT_DEF</xsl:attribute>
        <xsl:element name="xsl:text">
           <xsl:choose>
             <xsl:when test="$modifiers/time-format/@value">
                 <xsl:value-of select="$modifiers/time-format/@value"/>
             </xsl:when>
             <xsl:otherwise>
               <xsl:text>%d%H%MZ%b%y</xsl:text>
             </xsl:otherwise>
          </xsl:choose>
        </xsl:element> -->
	<!-- xsl:text -->
	<!--
      </xsl:element> -->
	<!-- xsl:variable -->
	<!-- Create a template that can be used to initialize all the number
           streams that exist as number-stream modifiers -->
	<!--
      <xsl:element name="xsl:template">
        <xsl:attribute name="name">initialize-message-functions</xsl:attribute>
-->
	<!-- For each inidivudal stream call the extension function to
             initialize the stream -->
	<!--
        <xsl:for-each select="$modifiers/number-stream">
          <xsl:element name="xsl:call-template">
            <xsl:attribute name="name">NUMBER_STREAM_FUN</xsl:attribute>

            <xsl:if test="@name">
              <xsl:element name="xsl:with-param">
                 <xsl:attribute name="name" select="'name'"/>
                 <xsl:attribute name="select" select="concat($apos, @name, $apos)"/>
              </xsl:element>
            </xsl:if>

            <xsl:if test="@first-value">
              <xsl:element name="xsl:with-param">
                 <xsl:attribute name="name" select="'first-value'"/>
                 <xsl:attribute name="select" select="concat($apos, @first-value, $apos)"/>
              </xsl:element>
            </xsl:if>

            <xsl:if test="@max-value">
              <xsl:element name="xsl:with-param">
                 <xsl:attribute name="name" select="'max-value'"/>
                 <xsl:attribute name="select" select="concat($apos, @max-value, $apos)"/>
              </xsl:element>
            </xsl:if>

            <xsl:if test="@int-format">
              <xsl:element name="xsl:with-param">
                 <xsl:attribute name="name" select="'int-format'"/>
                 <xsl:attribute name="select" select="concat($apos, @int-format, $apos)"/>
              </xsl:element>
            </xsl:if>

          </xsl:element> -->
	<!-- xsl:call-template -->
	<!--
        </xsl:for-each> -->
	<!-- $modifiers/number-stream -->
	<!--
      </xsl:element> -->
	<!-- xsl:template -->
	<!--
    </xsl:element> -->
	<!-- stylesheet -->
	<!--
  </xsl:result-document> -->
	<!-- modifiers stylesheet -->
	<!--
</xsl:template> -->
	<!-- write-default-formats -->
	<!--
!! TEMPLATE:    make-header-template
!! DESCRIPTION: This template creates a stylesheet to render and return the
!!              header and footer for a message. The resultant template is
!!              called with a parameter output-mode that will specify either
!!              'header' or 'footer'
-->
	<xsl:template name="make-header-template">
		<!-- Start the created stylesheet -->
		<xsl:element name="xsl:stylesheet">
			<xsl:attribute name="version">1.0</xsl:attribute>
			<!-- Add the tag to import the utility templates used by all messages -->
			<xsl:element name="xsl:import">
				<xsl:attribute name="href">../mes-util.xsl</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:output">
				<xsl:attribute name="method">text</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">output-mode</xsl:attribute>
				<xsl:attribute name="select">'header'</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">NL</xsl:attribute>
				<xsl:attribute name="select">$cr</xsl:attribute>
			</xsl:element>
			<!-- Create a template to render the header/footer. The template will be
         matching the message tag (<M>) output within CEP messages -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="match">/M</xsl:attribute>
				<!-- Depending on whether header or footer was passed to the parent
           template will determine the  template that is invoked to render
           the output -->
				<xsl:element name="xsl:choose">
					<xsl:element name="xsl:when">
						<xsl:attribute name="test">$output-mode = 'header'</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">render-header</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:when">
						<xsl:attribute name="test">$output-mode = 'footer'</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">render-footer</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<!-- xsl:choose -->
			</xsl:element>
			<!-- xsl:template -->
			<!-- Create the stylesheet template that is responsible for rendering a
         header -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="name">render-header</xsl:attribute>
				<!-- If the header uses any number stream functions with named number
           stream then we need to initialize the number streams first -->
				<xsl:if test="/header-footer/header//f[@n='NUMBER']">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">initialize-number-streams</xsl:attribute>
					</xsl:element>
				</xsl:if>
				<!-- Render the section for the header -->
				<xsl:call-template name="process-section-old">
					<xsl:with-param name="rel-pos" select="''"/>
					<xsl:with-param name="context" select="header"/>
					<xsl:with-param name="modifiers" select="/header-footer/modifiers"/>
				</xsl:call-template>
			</xsl:element>
			<!-- xsl:template -->
			<!-- Create a stylesheet template to render the footer -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="name">render-footer</xsl:attribute>
				<!-- If the footer uses any number stream functions with named number
           stream then we need to initialize the number streams first -->
				<xsl:if test="/header-footer/footer//f[@n='NUMBER']">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">initialize-number-streams</xsl:attribute>
					</xsl:element>
				</xsl:if>
				<!-- Process the footer section -->
				<xsl:call-template name="process-section-old">
					<xsl:with-param name="rel-pos" select="''"/>
					<xsl:with-param name="context" select="footer"/>
					<xsl:with-param name="modifiers" select="/header-footer/modifiers"/>
				</xsl:call-template>
			</xsl:element>
			<!-- xsl:template -->
			<!-- If a number function appeared in either the header or footer we must
         provide the template to initialize the number streams -->
			<xsl:if test="//f[@n='NUMBER']">
				<xsl:call-template name="create-number-stream-template">
					<xsl:with-param name="modifiers" select="/header-footer/modifiers"/>
				</xsl:call-template>
			</xsl:if>
		</xsl:element>
		<!-- xsl:stylesheet -->
	</xsl:template>
	<!-- make-header-template -->
	<!--
!! TEMPLATE:    make-subject-template
!! DESCRIPTION: This template creates the stylesheet to format a single
!!              subject line.
-->
	<xsl:template name="make-subject-template">
		<!-- Start the created stylesheet -->
		<xsl:element name="xsl:stylesheet">
			<xsl:attribute name="version">1.0</xsl:attribute>
			<!-- Add the tag to import the utility templates used by all messages -->
			<xsl:element name="xsl:import">
				<xsl:attribute name="href">../../../mes-util.xsl</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:output">
				<xsl:attribute name="method">text</xsl:attribute>
			</xsl:element>
			<!-- Create a template to render the subject line. The template will be
         matching the message tag (<M>) output within CEP messages -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="match">/M</xsl:attribute>
				<!-- If the subject line uses a number function then we must initialize
           the number streams with the system first -->
				<xsl:if test="subject/line//f[@n='NUMBER']">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">initialize-number-streams</xsl:attribute>
					</xsl:element>
				</xsl:if>
				<!-- Process the subject line -->
				<xsl:call-template name="process-line-old">
					<xsl:with-param name="rel-pos" select="''"/>
					<xsl:with-param name="context" select="subject/line"/>
					<xsl:with-param name="modifiers" select="/msgs/modifiers"/>
				</xsl:call-template>
			</xsl:element>
			<!--xsl:template  -->
			<!-- If a number function appeared in the subject we must provide the
         template to initialize the number streams -->
			<xsl:if test="subject/line//f[@n='NUMBER']">
				<xsl:call-template name="create-number-stream-template">
					<xsl:with-param name="modifiers" select="/msgs/modifiers"/>
				</xsl:call-template>
			</xsl:if>
		</xsl:element>
		<!-- xsl:stylesheet -->
	</xsl:template>
	<!-- make-subject-template -->
	<!--
!! TEMPLATE:    make-message-template
!! DESCRIPTION: Create a stylesheet which will transform a CEP XML message
!!              into the formatted output.
-->
	<xsl:template name="make-message-template">
		<!-- Start the created stylesheet -->
		<xsl:element name="xsl:stylesheet">
			<xsl:attribute name="version">1.0</xsl:attribute>
			<!-- Add the tag to import the utility templates used by all messages -->
			<xsl:element name="xsl:import">
				<xsl:attribute name="href">../../../mes-util.xsl</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:output">
				<xsl:attribute name="method">text</xsl:attribute>
			</xsl:element>
			<!-- Define the newline variable -->
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">NL</xsl:attribute>
				<xsl:attribute name="select">$cr</xsl:attribute>
			</xsl:element>
			<!-- Create top level template that will match the the CEP message tag -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="match">/M</xsl:attribute>
				<!-- Just render the body (formerly we had the subject and body being
           rendered as the message text) -->
				<!-- added by ws-5-7 start -->
				<!-- initialize table status to 0 -->
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-table-status</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">status</xsl:attribute>
						<xsl:attribute name="select">'0'</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<!-- initialize table header to null -->
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-table-header</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">head</xsl:attribute>
						<xsl:attribute name="select">''</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-caption</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">caption</xsl:attribute>
						<xsl:attribute name="select">''</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<!-- added by ws-5-7 stop -->
				<!-- added by ws start-->
				<xsl:value-of select="$cr"/>
				<xsl:text>&lt;html&gt;</xsl:text>
				<xsl:value-of select="$cr"/>
				<xsl:text>&lt;body&gt;</xsl:text>
				<xsl:value-of select="$cr"/>
				<!-- added by ws stop -->
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">render-body</xsl:attribute>
				</xsl:element>
				<!-- added by ws start -->
				<xsl:value-of select="$cr"/>
				<xsl:text>&lt;/body&gt;</xsl:text>
				<xsl:value-of select="$cr"/>
				<xsl:text>&lt;/html/&gt;</xsl:text>
				<xsl:value-of select="$cr"/>
				<!-- added by ws stop -->
			</xsl:element>
			<!-- Create the template to render the body of the message -->
			<xsl:element name="xsl:template">
				<xsl:attribute name="name">render-body</xsl:attribute>
				<!-- If the message uses a number function then we must initialize
           the number streams with the system first -->
				<xsl:if test="main//f[@n='NUMBER']">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">initialize-number-streams</xsl:attribute>
					</xsl:element>
				</xsl:if>
				<!-- render the message body -->
				<xsl:call-template name="process-section">
					<xsl:with-param name="rel-pos" select="''"/>
					<xsl:with-param name="context" select="main"/>
					<xsl:with-param name="modifiers" select="/msgs/modifiers"/>
				</xsl:call-template>
			</xsl:element>
			<!-- xsl:template -->
			<xsl:call-template name="ws-function">
    </xsl:call-template>
			<!-- If a number function appeared in the message we must
         provide the template to initialize the number streams -->
			<xsl:if test="main//f[@n='NUMBER']">
				<xsl:call-template name="create-number-stream-template">
					<xsl:with-param name="modifiers" select="/msgs/modifiers"/>
				</xsl:call-template>
			</xsl:if>
		</xsl:element>
		<!-- xsl:stylesheet -->
	</xsl:template>
	<!-- make-message-template -->
	<!--
!! TEMPLATE:    process-section
!! DESCRIPTION: Create the stylesheet commands to process the contents of a
!!              message.
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   context    The XPATH within the MFP XML tree with which we are dealing
-->
	<!-- A section contains lines, subs and groups. -->
	<xsl:template name="process-section">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<!-- Go through each child node within the MFP XML tree and call the
       appropriate template to process it -->
		<xsl:for-each select="$context/*">
			<xsl:choose>
				<xsl:when test="name() = 'line'">
					<xsl:call-template name="process-line">
						<xsl:with-param name="rel-pos" select="$rel-pos"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="name() = 'group'">
					<xsl:call-template name="process-group">
						<xsl:with-param name="rel-pos" select="concat($rel-pos,'G',@n,'/')"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="name() = 'sub'">
					<xsl:call-template name="process-sub">
						<xsl:with-param name="rel-pos" select="concat($rel-pos,'S',@n,'/')"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<!-- process-section -->
	<xsl:template name="process-section-old">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<!-- Go through each child node within the MFP XML tree and call the
       appropriate template to process it -->
		<xsl:for-each select="$context/*">
			<xsl:choose>
				<xsl:when test="name() = 'line'">
					<xsl:call-template name="process-line-old">
						<xsl:with-param name="rel-pos" select="$rel-pos"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="name() = 'group'">
					<xsl:call-template name="process-group">
						<xsl:with-param name="rel-pos" select="concat($rel-pos,'G',@n,'/')"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="name() = 'sub'">
					<xsl:call-template name="process-sub">
						<xsl:with-param name="rel-pos" select="concat($rel-pos,'S',@n,'/')"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<!-- process-section old -->
	<!--
!! TEMPLATE:    process-sub
!! DESCRIPTION: Process the MFP output of a sub node. The node itself contains
!!              the sub number and children nodes which can be other subs,
!!              groups, or lines.
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
-->
	<xsl:template name="process-sub">
		<xsl:param name="rel-pos"/>
		<xsl:param name="modifiers"/>
		<!-- Create the stylesheet commands to go through this child node of the
       current XPATH -->
		<xsl:element name="xsl:for-each">
			<xsl:attribute name="select"><xsl:value-of select="concat('S',@n)"/></xsl:attribute>
			<!-- Call the recursive template that will create the stylesheet commands
         for the children nodes -->
			<xsl:call-template name="process-section">
				<xsl:with-param name="rel-pos" select="$rel-pos"/>
				<xsl:with-param name="modifiers" select="$modifiers"/>
			</xsl:call-template>
		</xsl:element>
		<!-- xsl:for-each -->
	</xsl:template>
	<!-- process-sub -->
	<!--
!! TEMPLATE:    process-group
!! DESCRIPTION: Process the MFP output of a group node. The node itself contains
!!              the group number and children nodes which can be subs, other
!!              groups, or lines.
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
-->
	<xsl:template name="process-group">
		<xsl:param name="rel-pos"/>
		<xsl:param name="modifiers"/>
		<!-- Create the stylesheet commands to go through this child node of the
       current XPATH -->
		<xsl:element name="xsl:for-each">
			<xsl:attribute name="select"><xsl:value-of select="concat('G',@n,'/R')"/></xsl:attribute>
			<!-- Call the recursive template that will create the stylesheet commands
         for the children nodes -->
			<xsl:call-template name="process-section">
				<xsl:with-param name="rel-pos" select="$rel-pos"/>
				<xsl:with-param name="modifiers" select="$modifiers"/>
			</xsl:call-template>
		</xsl:element>
		<!-- xsl:for-each -->
	</xsl:template>
	<!-- process-group -->
	<!--
!! TEMPLATE:    process-line
!! DESCRIPTION: Create the stylesheet commands to process an MFP line tag.
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   context    The XPATH within the MFP XML tree with which we are dealing
-->
	<!-- added by ws-2013-5-6 start -->
	<xsl:template name="display-table-header">
		<xsl:param name="header-string" select="' '"/>
		<xsl:variable name="first-string" select="substring-before($header-string,' ')"/>
		<xsl:if test="string-length($first-string) !=0">
			<xsl:value-of select="$cr"/>
			<xsl:text>&lt;th style="border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;</xsl:text>
			<xsl:value-of select="$first-string"/>
			<xsl:text>&lt;/th&gt;</xsl:text>
			<xsl:call-template name="display-table-header">
				<xsl:with-param name="header-string" select="substring-after($header-string,' ')"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
	<!-- added by ws-2013-5-6 stop -->
	<!--
!! TEMPLATE:    process-line-old
!! DESCRIPTION: Create the stylesheet commands to process an MFP line tag.
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   context    The XPATH within the MFP XML tree with which we are dealing
-->
	<xsl:template name="process-line-old">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<xsl:for-each select="$context/node()">
			<!-- Take different action depending on the node contents -->
			<xsl:choose>
				<!-- If there is no name associated with this node then we have text
           data. Add a node to the output stylesheet with the node data. Ignore
           any children that just contain newlines since these are there
           merely for MFP output readability -->
				<xsl:when test="name() = ''">
					<xsl:variable name="text-val" select="translate(.,$newline,'')"/>
					<xsl:if test="string-length($text-val) != 0">
						<xsl:element name="xsl:text">
							<xsl:value-of select="$text-val"/>
						</xsl:element>
					</xsl:if>
				</xsl:when>
				<!-- If there are formatting attributes within the node then we
           need to create stylehseet wrapper code for formatting. Formatting
           attributes include width (@w), precision (@p), plus sign (@s),
           justification (@j), or type output (@t which can be f for float,
           d for decimal/integer, or s for string - the default when absent) -->
				<xsl:when test="@w != '' or @p != '' or @s != '' or @j != '' or @t = 'd' or @t = 'f'">
					<!-- Justification may or may not be present. Force a right-justifi-
             cation when absent -->
					<xsl:variable name="just">
						<xsl:choose>
							<xsl:when test="@j">
								<xsl:value-of select="@j"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>right</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- The type attribute may or may not be present. Default to a string
             type when absent -->
					<xsl:variable name="type">
						<xsl:choose>
							<xsl:when test="@t = 'd'">
								<xsl:text>integer</xsl:text>
							</xsl:when>
							<xsl:when test="@t = 'f'">
								<xsl:text>float</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>string</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- Create a call to a template that will format the data passing
             in the necessary parameters. The actual called template resides
             in the mes-util.xsl file. The name of the template is derived
             from the type and justification (e.g. format-string-right). The
             first parameter, which specifies the value to be printed, will be
             determined by the process-data-item template -->
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name"><xsl:value-of select="concat('format-',$type,'-',$just)"/></xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">str</xsl:attribute>
							<xsl:call-template name="process-data-item">
								<xsl:with-param name="rel-pos" select="$rel-pos"/>
								<xsl:with-param name="modifiers" select="$modifiers"/>
							</xsl:call-template>
						</xsl:element>
						<xsl:if test="@w">
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">width</xsl:attribute>
								<xsl:attribute name="select"><xsl:value-of select="@w"/></xsl:attribute>
							</xsl:element>
						</xsl:if>
						<xsl:if test="@p and $type = 'string'">
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">trim</xsl:attribute>
								<xsl:attribute name="select"><xsl:value-of select="@p"/></xsl:attribute>
							</xsl:element>
						</xsl:if>
						<xsl:if test="@p and $type != 'string'">
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">precision</xsl:attribute>
								<xsl:attribute name="select"><xsl:value-of select="@p"/></xsl:attribute>
							</xsl:element>
						</xsl:if>
						<xsl:if test="@s">
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">sign</xsl:attribute>
								<xsl:attribute name="select"><xsl:value-of select="'yes'"/></xsl:attribute>
							</xsl:element>
						</xsl:if>
					</xsl:element>
					<!-- xsl:call-template -->
				</xsl:when>
				<!-- formatting data is present -->
				<!-- Deal with a br tag which signifies a line break -->
				<xsl:when test="name() = 'br'">
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select">$NL</xsl:attribute>
					</xsl:element>
				</xsl:when>
				<!-- must have a simple data item tag for a function (<f>), a literal
           (<d>), or a data argument (e.g. <S3.G1.D4/>)-->
				<xsl:otherwise>
					<xsl:call-template name="process-data-item">
						<xsl:with-param name="rel-pos" select="$rel-pos"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
		<!--$context/node()  -->
	</xsl:template>
	<!-- process-line-old -->
	<xsl:template name="process-line">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<xsl:for-each select="$context/node()">
			<!-- Take different action depending on the node contents -->
			<xsl:choose>
				<!-- If there is no name associated with this node then we have text
           data. Add a node to the output stylesheet with the node data. Ignore
           any children that just contain newlines since these are there
           merely for MFP output readability -->
				<xsl:when test="name() = ''">
					<xsl:variable name="text-val" select="translate(.,$newline,'')"/>
					<xsl:if test="string-length($text-val) != 0">
						<!-- added by ws start -->
						<xsl:variable name="normalized-text" select="normalize-space($text-val)"/>
						<xsl:choose>
							<xsl:when test="$normalized-text='__stop_table'">
								<xsl:element name="xsl:call-template">
									<xsl:attribute name="name">stop-table</xsl:attribute>
								</xsl:element>
							</xsl:when>
							<xsl:otherwise>
								<xsl:variable name="strip-space-text" select="concat($normalized-text,'|')"/>
								<xsl:variable name="first-word" select="substring-before($strip-space-text,'|')"/>
								<xsl:choose>
									<xsl:when test="$first-word='__start_table' or $first-word='__start_table '">
										<xsl:element name="xsl:call-template">
											<xsl:attribute name="name">save-header</xsl:attribute>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">header-string</xsl:attribute>
												<xsl:value-of select="substring-after($normalized-text,'|')"/>
											</xsl:element>
										</xsl:element>
									</xsl:when>
									<xsl:when test="starts-with($first-word,'caption')=true()">
										<xsl:element name="xsl:call-template">
											<xsl:attribute name="name">set-caption</xsl:attribute>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">caption</xsl:attribute>
												<xsl:value-of select="substring-after($text-val,'|')"/>
											</xsl:element>
										</xsl:element>
										<xsl:element name="xsl:call-template">
											<xsl:attribute name="name">set-table-status</xsl:attribute>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">status</xsl:attribute>
												<xsl:attribute name="select">6</xsl:attribute>
											</xsl:element>
										</xsl:element>
									</xsl:when>
									<xsl:when test="string-length($normalized-text)!=0 and starts-with($first-word,'caption')=false() and starts-with($first-word,'__start_table')=false()">
										<xsl:element name="xsl:call-template">
											<xsl:attribute name="name">parse-col</xsl:attribute>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">target-string</xsl:attribute>
												<xsl:if test="starts-with($normalized-text,'|')">
													<xsl:value-of select="substring-after($text-val,'|')"/>
												</xsl:if>
												<xsl:if test="starts-with($normalized-text,'|')=false()">
													<xsl:value-of select="$text-val"/>
												</xsl:if>
											</xsl:element>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">is-begin-with-slide</xsl:attribute>
												<xsl:if test="starts-with($normalized-text,'|')">
                  	1
                  </xsl:if>
												<xsl:if test="starts-with($normalized-text,'|')=false()">
                  	0
                  </xsl:if>
											</xsl:element>
										</xsl:element>
									</xsl:when>
									<xsl:when test="string-length($normalized-text)=0 and string-length($text-val)!=0">
										<xsl:element name="xsl:call-template">
											<xsl:attribute name="name">parse-col</xsl:attribute>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">target-string</xsl:attribute>
												<xsl:element name="xsl:value-of">
													<xsl:attribute name="select"><xsl:text>'</xsl:text><xsl:value-of select="$text-val"/><xsl:text>'</xsl:text></xsl:attribute>
												</xsl:element>
											</xsl:element>
											<xsl:element name="xsl:with-param">
												<xsl:attribute name="name">is-begin-with-slide</xsl:attribute>
												<xsl:attribute name="select">0</xsl:attribute>
											</xsl:element>
										</xsl:element>
									</xsl:when>
								</xsl:choose>
							</xsl:otherwise>
						</xsl:choose>
						<!-- added by ws stop -->
					</xsl:if>
				</xsl:when>
				<!-- If there are formatting attributes within the node then we
           need to create stylehseet wrapper code for formatting. Formatting
           attributes include width (@w), precision (@p), plus sign (@s),
           justification (@j), or type output (@t which can be f for float,
           d for decimal/integer, or s for string - the default when absent) -->
				<xsl:when test="@w != '' or @p != '' or @s != '' or @j != '' or @t = 'd' or @t = 'f'">
					<!-- Justification may or may not be present. Force a right-justifi-
             cation when absent -->
					<xsl:variable name="just">
						<xsl:choose>
							<xsl:when test="@j">
								<xsl:value-of select="@j"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>right</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- The type attribute may or may not be present. Default to a string
             type when absent -->
					<xsl:variable name="type">
						<xsl:choose>
							<xsl:when test="@t = 'd'">
								<xsl:text>integer</xsl:text>
							</xsl:when>
							<xsl:when test="@t = 'f'">
								<xsl:text>float</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>string</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<!-- Create a call to a template that will format the data passing
             in the necessary parameters. The actual called template resides
             in the mes-util.xsl file. The name of the template is derived
             from the type and justification (e.g. format-string-right). The
             first parameter, which specifies the value to be printed, will be
             determined by the process-data-item template -->
					<xsl:element name="xsl:variable">
						<xsl:attribute name="name">out-string</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name"><xsl:value-of select="concat('format-',$type,'-',$just)"/></xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">str</xsl:attribute>
								<xsl:call-template name="process-data-item">
									<xsl:with-param name="rel-pos" select="$rel-pos"/>
									<xsl:with-param name="modifiers" select="$modifiers"/>
								</xsl:call-template>
							</xsl:element>
							<xsl:if test="@w">
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">width</xsl:attribute>
									<xsl:attribute name="select"><xsl:value-of select="@w"/></xsl:attribute>
								</xsl:element>
							</xsl:if>
							<xsl:if test="@p and $type = 'string'">
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">trim</xsl:attribute>
									<xsl:attribute name="select"><xsl:value-of select="@p"/></xsl:attribute>
								</xsl:element>
							</xsl:if>
							<xsl:if test="@p and $type != 'string'">
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">precision</xsl:attribute>
									<xsl:attribute name="select"><xsl:value-of select="@p"/></xsl:attribute>
								</xsl:element>
							</xsl:if>
							<xsl:if test="@s">
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">sign</xsl:attribute>
									<xsl:attribute name="select"><xsl:value-of select="'yes'"/></xsl:attribute>
								</xsl:element>
							</xsl:if>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">display_cur_text</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">in_string</xsl:attribute>
							<xsl:attribute name="select">$out-string</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<!-- xsl:call-template -->
				</xsl:when>
				<!-- formatting data is present -->
				<!-- Deal with a br tag which signifies a line break -->
				<xsl:when test="name() = 'br'">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">process-br</xsl:attribute>
					</xsl:element>
				</xsl:when>
				<!-- must have a simple data item tag for a function (<f>), a literal
           (<d>), or a data argument (e.g. <S3.G1.D4/>)-->
				<xsl:otherwise>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">display_cur_text</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">in_string</xsl:attribute>
							<xsl:call-template name="process-data-item">
								<xsl:with-param name="rel-pos" select="$rel-pos"/>
								<xsl:with-param name="modifiers" select="$modifiers"/>
							</xsl:call-template>
						</xsl:element>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
		<!--$context/node()  -->
	</xsl:template>
	<!-- process-line -->
	<!--
!! TEMPLATE:    process-data-item
!! DESCRIPTION: Line arguments from the Message Definition Files are translated
!!              into data items within the intermediate XML file. These data
!!              items appear in-line within the intermediate XML file and may
!!              be literal items <d> (e.g. DRY_WEIGHT), functions <f> (e.g.
!!              UOM_AMT), or argument references such as <S12.G1.D1>.
!!
!!              This template will translate these data items into either a
!!              a text node (for literals), a template call (for functions),
!!              or a value of node with the reference translated to a path.
!!
!!              All of these may be wrapped inside a case modification template.
!!
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   context    The XPATH within the MFP XML tree with which we are dealing
!!   inside-func Is this data item within a function tag, <f>, or not (1 or 0
!!              respecively.
-->
	<xsl:template name="process-data-item">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<xsl:param name="inside-func" select="0"/>
		<!-- Save the name of the current node. -->
		<xsl:variable name="name" select="name($context)"/>
		<!-- Create a variable which will contain the elements and attributes for
       the processing of the data item. We get this as a variable because
       afterwards we need to apply the modifiers to this data item -->
		<xsl:variable name="this_item">
			<!-- Different processing is done for each of the possible types for the
         data item (literal, function, or data argument) -->
			<xsl:choose>
				<!-- take care of data items or literals. These are translated to a text
           node with the node value being the literal -->
				<xsl:when test="$name = 'd'">
					<xsl:element name="xsl:text">
						<xsl:value-of select="."/>
					</xsl:element>
				</xsl:when>
				<!-- functions are processed by another template -->
				<xsl:when test="$name = 'f'">
					<xsl:call-template name="process-function">
						<xsl:with-param name="rel-pos" select="$rel-pos"/>
						<xsl:with-param name="context" select="$context"/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
					</xsl:call-template>
				</xsl:when>
				<!-- argument references such as <S2.S23.D4/> are translated into a
           value-of tag with a select of a path reference (S2/S23/D/@D/ for
           <S2.S23.D4/>) -->
				<xsl:otherwise>
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select"><xsl:call-template name="get-xpath"><xsl:with-param name="context" select="$rel-pos"/><xsl:with-param name="path" select="$name"/></xsl:call-template></xsl:attribute>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
			<!-- the type of variable (literal, function, or argument ref -->
		</xsl:variable>
		<!-- The results of processing this data item are now held in a variable.
       There may or may not be modifiers that need to be applied to it. If we
       are not processing a data item for a function call, then call the
       apply-modifiers template which will either apply the template calls
       for any modifiers, or print out the variable if there are no
       modifiers -->
		<xsl:choose>
			<xsl:when test="$inside-func = '0'">
				<xsl:call-template name="apply-modifiers">
					<xsl:with-param name="modifiers" select="$modifiers/*"/>
					<xsl:with-param name="argument" select="$this_item"/>
				</xsl:call-template>
			</xsl:when>
			<!-- we are inside a function; just pass back the current nodes -->
			<xsl:otherwise>
				<xsl:copy-of select="$this_item"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- process-data-item -->
	<!--
!! TEMPLATE:    process-function
!! DESCRIPTION: This template processes a function tag, <f>, into a
!!              call-template tag specifying the proper function name and
!!              arguments. Within the MFP a function tag may result from a
!!              vocabulary translation or real function within the Message
!!              Definition File.
!!
!! PARAMETERS:
!!   rel-pos    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   context    The XPATH within the MFP XML tree with which we are dealing
-->
	<xsl:template name="process-function">
		<xsl:param name="rel-pos"/>
		<xsl:param name="context" select="."/>
		<xsl:param name="modifiers"/>
		<!-- Get the name of the function -->
		<xsl:variable name="func-name" select="@n"/>
		<!-- Check if the function is actually the name of a vocabulary item -->
		<xsl:variable name="is-voc-fun">
			<xsl:call-template name="is-vocab">
				<xsl:with-param name="str" select="@n"/>
			</xsl:call-template>
		</xsl:variable>
		<!-- Add a call-template tag to the output to handle the processing of the
       function. For vocabulary function the template is get-vocab-value. For
       all other functions the name is the source name with _FUN attached
       (for example the function LOCATION has a corresponding template named
       LOCATION_FUN). -->
		<xsl:element name="xsl:call-template">
			<!-- Derive the template name from the function name -->
			<xsl:choose>
				<xsl:when test="$is-voc-fun = 'true'">
					<!-- It is a vocab function. -->
					<xsl:attribute name="name">get-vocab-value</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">vocab</xsl:attribute>
						<xsl:value-of select="@n"/>
					</xsl:element>
				</xsl:when>
				<xsl:otherwise>
					<!-- Its a normal function, get the function name. -->
					<xsl:attribute name="name"><xsl:value-of select="concat(@n,'_FUN')"/></xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
			<!-- Process each argument into a with-param tag. Arguments are separate
         tags within the function, which might be text, literals, functions,
         or argument references (e.g. <S23.d2>). All function and vocabulary
         templates have a sequential naming scheme for parameters:
         arg1, arg2, etc  -->
			<xsl:for-each select="$context/*">
				<xsl:element name="xsl:with-param">
					<!-- Compose the argument string. -->
					<xsl:attribute name="name"><xsl:value-of select="concat('arg',string(position()))"/></xsl:attribute>
					<!-- Process the argument value. -->
					<xsl:call-template name="process-data-item">
						<xsl:with-param name="rel-pos" select="$rel-pos"/>
						<xsl:with-param name="context" select="."/>
						<xsl:with-param name="modifiers" select="$modifiers"/>
						<xsl:with-param name="inside-func" select="1"/>
					</xsl:call-template>
				</xsl:element>
			</xsl:for-each>
			<!-- end for each argument -->
			<!-- Take care of optional arguments to functions. These are all format
         arguments. If the function does not have the optional argument and
         a format specification modifier was provided then we should insert
         the format specification modifier value -->
			<xsl:if test="$func-name = 'LOCATION' and $modifiers/location-format/@value and count($context/*) = 2">
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">arg3</xsl:attribute>
					<xsl:value-of select="$modifiers/location-format/@value"/>
				</xsl:element>
			</xsl:if>
			<xsl:if test="$func-name = 'DURATION' and $modifiers/duration-format/@value and count($context/*) = 1">
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">arg2</xsl:attribute>
					<xsl:value-of select="$modifiers/duration-format/@value"/>
				</xsl:element>
			</xsl:if>
			<xsl:if test="$func-name = 'GTIME' and $modifiers/time-format/@value and count($context/*) = 1">
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">arg2</xsl:attribute>
					<xsl:value-of select="$modifiers/time-format/@value"/>
				</xsl:element>
			</xsl:if>
			<xsl:if test="$func-name = 'CLOCK' and $modifiers/time-format/@value and count($context/*) = 0">
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">arg1</xsl:attribute>
					<xsl:value-of select="$modifiers/time-format/@value"/>
				</xsl:element>
			</xsl:if>
		</xsl:element>
		<!-- call-template -->
	</xsl:template>
	<!-- process-function -->
	<!--
!! TEMPLATE:    apply-modifiers
!! DESCRIPTION: Recursively apply the text changing modifiers within the
!!              modifier node set to the argument output. We apply them in
!!              reverse order so that the innermost XSL instruction is for
!!              the first modifier.
!! PARAMETER:
!!   modifers   node set of data item changing modifiers
!!   argument   The data argument to be modified
-->
	<xsl:template name="apply-modifiers">
		<xsl:param name="modifiers"/>
		<xsl:param name="argument"/>
		<!-- Process the modifiers in reverse order so that the first modifier ends
       up being the innermost within the equence of template calls. The effect
       of this is that the first modifer (which is the innermost) will be
       applied first to the passed in argument. The next innermost (which is
       the 2nd modifier) will then be applied to the result, etc. So modifiers
       end up being applied in the order they appear in the MDF file -->
		<xsl:variable name="this_modifier" select="$modifiers[position() = last()]"/>
		<xsl:variable name="remaining_modifiers" select="$modifiers[not(position() = last())]"/>
		<xsl:choose>
			<!-- If there are no modifiers left then use the value of the argument.
         If there were no modifiers at all then this just outputs the original
         value. If there were modifiers then this is the argument for the
         innermost modifier -->
			<xsl:when test="count($modifiers) = 0">
				<xsl:copy-of select="$argument"/>
			</xsl:when>
			<!-- If this is a character-case modifier then the value attribute specifies
         whether we are making the argument uppercase or lowercase, and by
         extension that specifies the template function to call -->
			<xsl:when test="$this_modifier/name() = 'character-case'">
				<xsl:variable name="function" select="concat($this_modifier/@value,'_FUN')"/>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name" select="$function"/>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name" select="'arg1'"/>
						<!-- recursively call this template to apply the next modifier -->
						<xsl:call-template name="apply-modifiers">
							<xsl:with-param name="modifiers" select="$remaining_modifiers"/>
							<xsl:with-param name="argument" select="$argument"/>
						</xsl:call-template>
					</xsl:element>
				</xsl:element>
			</xsl:when>
			<!-- If this is a replace modifier then attribute value1 specifies the
         string to replace and value2 the replacement text. Within the 
         REPLACE_FUN arg1 is the string to apply the replacements on, arg2 is
         the string to replace and arg3 is the replacement text. -->
			<xsl:when test="$this_modifier/name() = 'replace'">
				<xsl:variable name="function" select="'REPLACE_FUN'"/>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name" select="$function"/>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name" select="'arg1'"/>
						<!-- recursively call this template to apply the next modifier -->
						<xsl:call-template name="apply-modifiers">
							<xsl:with-param name="modifiers" select="$remaining_modifiers"/>
							<xsl:with-param name="argument" select="$argument"/>
						</xsl:call-template>
					</xsl:element>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name" select="'arg2'"/>
						<xsl:value-of select="$this_modifier/@value1"/>
					</xsl:element>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name" select="'arg3'"/>
						<xsl:value-of select="$this_modifier/@value2"/>
					</xsl:element>
				</xsl:element>
				<!-- name="xsl:call-template" -->
			</xsl:when>
			<!-- There are other modifiers, but they provide default formats or
         specify number streams. They do not directly alter text. Therefore
         we just skip over them -->
			<xsl:otherwise>
				<xsl:call-template name="apply-modifiers">
					<xsl:with-param name="modifiers" select="$remaining_modifiers"/>
					<xsl:with-param name="argument" select="$argument"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- apply-modifiers -->
	<!--
!! TEMPLATE:    is-vocab
!! DESCRIPTION: test if a string is a vocab item (Static or Dynamic). Return
!!              value is 'true' or 'false'.
!! PARAMETER:
!!   str        The name to check for a matching vocabulary name
-->
	<xsl:template name="is-vocab">
		<xsl:param name="str"/>
		<!-- Create a list of recognized function names -->
		<xsl:variable name="func-names">
			<xsl:text>*CLASSIFICATION*CLOCK*DURATION*GTIME*LOCATION*LOWER*</xsl:text>
			<xsl:text>*NUMBER*REPLACE*SCENARIO*SLP_SC_AMT*SLP_SC_UOM*</xsl:text>
			<xsl:text>*STRIP_AFTER*SUBCAT_NAME*UOM*UOM_AMT*UPPER*VARIABLE*</xsl:text>
			<xsl:text>*WRAP*</xsl:text>
			<xsl:text>*unit_name_transform*</xsl:text>
			<xsl:text>*trans_word*</xsl:text>
		</xsl:variable>
		<!-- Simple check - if the passed in string is within the list of functions
       then it is a function. Otherwise it is a vocabulary item -->
		<xsl:choose>
			<xsl:when test="contains($func-names,concat('*',$str,'*'))">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<xsl:otherwise>true</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- is-vocab -->
	<!--
!! TEMPLATE:    get-xpath
!! DESCRIPTION: Translate an argument reference into an XPath expression.
!!              All paths that do not contain a group are absolute.
!!              examples: S2.S1.G1.S1.D1 = S1/D/@A
!!                        S2.S23.D4 = S2/S23/D/@D
!! PARAMETERS:
!!   context    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   path       The name of the tag with which we are dealing (.e.g. <S2.S23.D4>)
-->
	<xsl:template name="get-xpath">
		<xsl:param name="context"/>
		<xsl:param name="path"/>
		<!-- Extract and translate the root of the path into an XML reference
       (e.g. <S2.S23.D4> has a path root of S2/S23) -->
		<xsl:variable name="dir" select="substring-before($path,'D')"/>
		<xsl:variable name="tdir" select="translate($dir,'.','/')"/>
		<!-- Data items at the root level need separate handling e.g. D2 = /M/D/@A -->
		<xsl:choose>
			<!-- Root data items need the message prefix -->
			<xsl:when test="substring($path,1,1) = 'D'">
				<xsl:text>/M/</xsl:text>
			</xsl:when>
			<!-- All other data items have their context translated -->
			<xsl:otherwise>
				<xsl:call-template name="get-context-prefix">
					<xsl:with-param name="path" select="$path"/>
					<xsl:with-param name="context" select="$context"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
		<!-- Last thing is to translate the argument ID into an alpabetic parameter.
       For example D5 equates to D/@E -->
		<xsl:call-template name="get-data-path">
			<xsl:with-param name="tag" select="substring-after($path,$dir)"/>
		</xsl:call-template>
	</xsl:template>
	<!-- get-xpath -->
	<!--
!! TEMPLATE:    get-context-prefix
!! DESCRIPTION: Determines the relative prefix for a path given the context.
!!              For example given:
!!                 context = S24/S2/
!!                 path    = S24.D2
!!              the prefix would be ../ because the data is up one level in
!!              the tree.
!!
!!              A further example:
!!                 context = S24/G2/S3/
!!                 path    = S24.D2
!!              Generates a prefix of ../../../ because we added an additional
!!              level to account for the fact that records consume 2 levels in
!!              the CEP XML output (S24/G2/R/S3/D2) which is not reflected in
!!              the Message Definition Files.
!!
!!              We also check if the path is relative to the context, and if
!!              not we throw an error. For example,
!!                context = S24/G2/S3/
!!                path    = S24.G2.S2.D2
!!              is an error because the path does not appear in the context
!!              (context has S3 and the path has S2).
!!
!! PARAMETERS:
!!   path       The name of the tag with which we are dealing (.e.g. S2.S23.D4).
!!              This is equivalent to an argument reference within the Message
!!              Definition Files.
!!   context    The XPATH within the CEP XML tree with which we are dealing
!!              (e.g. S2/G2/S1/)
!!   original-path The path with which this template was first called from
!!              another template. This is only used for recursive invocations
!!              of this file.
-->
	<xsl:template name="get-context-prefix">
		<xsl:param name="path"/>
		<xsl:param name="context"/>
		<xsl:param name="original-path" select="$path"/>
		<!-- Get the prefix of the context ex: S23/S2/G1 has a prefix of S23. -->
		<xsl:variable name="con-prefix" select="substring-before($context,'/')"/>
		<xsl:variable name="dot-prefix" select="concat($con-prefix,'.')"/>
		<!-- If the context and the path start the same then things are correct at
       the first level. Otherwise, if they are wrong we need to move up the
       tree to this first level and follow the path back down -->
		<xsl:choose>
			<!-- If the context prefix matches the path recursively call this template
         with the top level stripped off -->
			<xsl:when test="starts-with($path,$dot-prefix)">
				<xsl:call-template name="get-context-prefix">
					<xsl:with-param name="path" select="substring-after($path,$dot-prefix)"/>
					<xsl:with-param name="context" select="substring-after($context,concat($con-prefix,'/'))"/>
					<xsl:with-param name="original-path" select="$original-path"/>
				</xsl:call-template>
			</xsl:when>
			<!-- The path must be a reference to an item at this level (or an error).
         If, at this point, the path contains a ., this is an error -->
			<xsl:when test="contains($path,'.')">
				<xsl:call-template name="write-error">
					<xsl:with-param name="text" select="concat('Invalid data path ',$original-path)"/>
				</xsl:call-template>
			</xsl:when>
			<!-- Replace each remaining level of the context with "../" (for
        example S1/S24 becomes ../../). Replace Group levels with "../../"
        as records within the CEP XML output add another level -->
			<xsl:otherwise>
				<!-- Remove all numbers from the context and replace Gs with ../..
           so S1/S24/G3/ becomes S/S/../../ -->
				<xsl:variable name="tcontext">
					<xsl:call-template name="replace-function">
						<xsl:with-param name="str" select="translate($context,'SG0123456789','SG')"/>
						<xsl:with-param name="str-a" select="'G'"/>
						<xsl:with-param name="str-b" select="'../..'"/>
					</xsl:call-template>
				</xsl:variable>
				<!-- Replace all remaining Ss with .. so our example string
           S/S/../../ becomes ../../../../ -->
				<xsl:call-template name="replace-function">
					<xsl:with-param name="str" select="$tcontext"/>
					<xsl:with-param name="str-a" select="'S'"/>
					<xsl:with-param name="str-b" select="'..'"/>
				</xsl:call-template>
			</xsl:otherwise>
			<!-- the remaining path does not contain a period -->
		</xsl:choose>
	</xsl:template>
	<!-- get-context-prefix -->
	<!--
!! TEMPLATE:    create-number-stream-template
!! DESCRIPTION: This template create a template element that calls the number
!!              stream function (which initializes number streams) for each
!!              number stream specified in the modifiers.
-->
	<xsl:template name="create-number-stream-template">
		<xsl:param name="modifiers"/>
		<!-- Create a template that can be used to initialize all the number
       streams that exist as number-stream modifiers -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">initialize-number-streams</xsl:attribute>
			<!-- For each inidivudal stream call the extension function to initialize
         the stream -->
			<xsl:for-each select="$modifiers/number-stream">
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">NUMBER_STREAM_FUN</xsl:attribute>
					<xsl:if test="@name">
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name" select="'stream-name'"/>
							<xsl:attribute name="select" select="concat($apos, @name, $apos)"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="@first-value">
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name" select="'first-value'"/>
							<xsl:attribute name="select" select="concat($apos, @first-value, $apos)"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="@max-value">
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name" select="'max-value'"/>
							<xsl:attribute name="select" select="concat($apos, @max-value, $apos)"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="@int-format">
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name" select="'int-format'"/>
							<xsl:attribute name="select" select="concat($apos, @int-format, $apos)"/>
						</xsl:element>
					</xsl:if>
				</xsl:element>
				<!-- xsl:call-template -->
			</xsl:for-each>
			<!-- $modifiers/number-stream -->
		</xsl:element>
		<!-- xsl:template -->
	</xsl:template>
	<!-- create-number-stream-template -->
	<!--
!! TEMPLATE:    get-data-path
!! DESCRIPTION: Replaces a simple Message Definition File data reference with
!!              an XML path reference. The data item number corresponds to an
!!              alphabetic reference. If the data item is greater than 26 we
!!              start with double alpahebetucs. As examples:
!!              D1  = D/@A
!!              D26 = D/@Z
!!              D27 = D/@AA
!!              D28 = D/@AB
!! PARAMETERS:
!!   tag        The data item, such as D12
-->
	<xsl:template name="get-data-path">
		<xsl:param name="tag" select="name()"/>
		<!-- Set up the replacement string and remove the D for the tag so we only
       have a simple number to deal with -->
		<xsl:variable name="letters" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
		<xsl:variable name="d-num" select="number(translate($tag,'D',''))"/>
		<!-- All tags start with D/@, followed by the alpahabetic -->
		<xsl:text>D/@</xsl:text>
		<xsl:if test="$d-num &gt; 26">
			<xsl:value-of select="substring($letters,$d-num div 26,1)"/>
		</xsl:if>
		<xsl:value-of select="substring($letters,($d-num - 1) mod 26 + 1,1)"/>
	</xsl:template>
	<!-- get-data-path -->
	<!--
!! TEMPLATE:    replace-function
!! DESCRIPTION: Within string str, replace each occurence of string str-a with
!!              string str-b.
!! PARAMETERS:
!!   str        The root string which is having segments replace
!!   str-a      The id string within the root string that will be replaced
!!   str-b      The replace string with which to replace the id string
-->
	<xsl:template name="replace-function">
		<xsl:param name="str"/>
		<xsl:param name="str-a"/>
		<xsl:param name="str-b"/>
		<xsl:choose>
			<xsl:when test="contains($str,$str-a)">
				<xsl:call-template name="replace-function">
					<xsl:with-param name="str" select="concat(substring-before($str,$str-a),$str-b,substring-after($str,$str-a))"/>
					<xsl:with-param name="str-a" select="$str-a"/>
					<xsl:with-param name="str-b" select="$str-b"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$str"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- replace-function -->
	<!--
!! TEMPLATE:    write-error
!! DESCRIPTION: Writes out an error message
!! PARAMETERS:
!!   text       The error string to print
-->
	<xsl:template name="write-error">
		<xsl:param name="text" select="'Unknown error'"/>
		<xsl:value-of select="concat('__ERROR__: [',$text,'] __END_ERROR__')"/>
	</xsl:template>
	<!-- write-error -->
	<xsl:template name="ws-function">
		<!-- added by ws-5-6 start -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">display_cur_text</xsl:attribute>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">in_string</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">table_status</xsl:attribute>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">get-table-status</xsl:attribute>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">normalized-string</xsl:attribute>
				<xsl:attribute name="select">normalize-space($in_string)</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">space-string</xsl:attribute>
				<xsl:attribute name="select">$in_string</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=5</xsl:attribute>
				<xsl:element name="xsl:variable">
					<xsl:attribute name="name">header-temp</xsl:attribute>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">get-table-header</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-table-header</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">head</xsl:attribute>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">concat($header-temp,$in_string)</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=6</xsl:attribute>
				<xsl:element name="xsl:variable">
					<xsl:attribute name="name">caption-temp</xsl:attribute>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">get-caption</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-caption</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">caption</xsl:attribute>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">concat($caption-temp,$in_string)</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=0</xsl:attribute>
				<xsl:element name="xsl:if">
					<xsl:attribute name="test">starts-with($normalized-string,'|')=true()</xsl:attribute>
					<xsl:element name="xsl:variable">
						<xsl:attribute name="name">header</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">get-table-header</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:variable">
						<xsl:attribute name="name">caption</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">get-caption</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:if">
						<xsl:attribute name="test">string-length($header)!=0</xsl:attribute>
						<xsl:element name="xsl:if">
							<xsl:attribute name="test">string-length($caption)!=0</xsl:attribute>
							<xsl:element name="xsl:text">
                    		&lt;p align="center" style="font-family:黑体;font-weight:bold"&gt;
                    	</xsl:element>
							<xsl:element name="xsl:value-of">
								<xsl:attribute name="select">normalize-space($caption)</xsl:attribute>
							</xsl:element>
							<xsl:element name="xsl:text">
                    		 &lt;/p&gt;&lt;br/&gt;
                    	</xsl:element>
							<xsl:element name="xsl:call-template">
								<xsl:attribute name="name">set-caption</xsl:attribute>
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">caption</xsl:attribute>
									<xsl:attribute name="select">''</xsl:attribute>
								</xsl:element>
							</xsl:element>
						</xsl:element>
						<xsl:element name="xsl:text">
                        &lt;table border="2" cellspacing="2" cellpadding="3" width="90%" style="border-color:#666666;border-style:solid;border-width:2px;margin-left:15px"&gt;
                    </xsl:element>
						<xsl:element name="xsl:text">
                        &lt;tr style="word-wrap:break-word"&gt;
                    </xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">display-headers</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">header-string</xsl:attribute>
								<xsl:attribute name="select">$header</xsl:attribute>
							</xsl:element>
						</xsl:element>
						<xsl:element name="xsl:text">
                        &lt;/tr&gt;
                    </xsl:element>
						<xsl:element name="xsl:text">
                        &lt;tr style="word-wrap:break-word"&gt;
                    </xsl:element>
						<xsl:element name="xsl:text">
                        &lt;td style="border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;
                    </xsl:element>
						<xsl:element name="xsl:if">
							<xsl:attribute name="test">string-length($header)>1</xsl:attribute>
							<xsl:element name="xsl:value-of">
								<xsl:attribute name="select">substring-after($normalized-string,'|')</xsl:attribute>
							</xsl:element>
						</xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">set-table-status</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">status</xsl:attribute>
								<xsl:attribute name="select">3</xsl:attribute>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:if">
						<xsl:attribute name="test">string-length($header)=0</xsl:attribute>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">$space-string</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:if">
					<xsl:attribute name="test">starts-with($normalized-string,'|')=false()</xsl:attribute>
					<xsl:element name="xsl:variable">
						<xsl:attribute name="name">caption-temp</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">get-caption</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:if">
						<xsl:attribute name="test">string-length($caption-temp)!=0</xsl:attribute>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">$caption-temp</xsl:attribute>
						</xsl:element>
						<xsl:element name="xsl:text">
                    		&lt;br/&gt;
                    	</xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">set-caption</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">caption</xsl:attribute>
								<xsl:attribute name="select">''</xsl:attribute>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select">$space-string</xsl:attribute>
					</xsl:element>
					<!--<xsl:element name="xsl:value-of">
                    <xsl:attribute name="select">$space-string</xsl:attribute>
                </xsl:element>
                -->
				</xsl:element>
				<!-- xsl:if -->
			</xsl:element>
			<!-- xsl:if -->
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=1</xsl:attribute>
				<xsl:element name="xsl:choose">
					<xsl:element name="xsl:when">
						<xsl:attribute name="test">starts-with($normalized-string,'|')=true()</xsl:attribute>
						<xsl:element name="text">
                        &lt;tr&gt;
                    </xsl:element>
						<xsl:element name="text">
                        &lt;td style="border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;
                    </xsl:element>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">substring-after($normalized-string,'|')</xsl:attribute>
						</xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">set-table-status</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">status</xsl:attribute>
								<xsl:attribute name="select">3</xsl:attribute>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:otherwise">
						<xsl:element name="text">
                        &lt;/table&gt;
                    </xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">set-table-status</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">status</xsl:attribute>
								<xsl:attribute name="select">0</xsl:attribute>
							</xsl:element>
						</xsl:element>
						<!--
                    <xsl:element name="xsl:call-template">
                        <xsl:attribute name="name">set-table-header</xsl:attribute>
                        <xsl:element name="xsl:with-param">
                            <xsl:attribute name="name">head</xsl:attribute>
                            <xsl:attribute name="select">''</xsl:attribute>
                        </xsl:element>
                    </xsl:element>
                    -->
						<xsl:element name="xsl:variable">
							<xsl:attribute name="name">caption-temp</xsl:attribute>
							<xsl:element name="xsl:call-template">
								<xsl:attribute name="name">get-caption</xsl:attribute>
							</xsl:element>
						</xsl:element>
						<xsl:element name="xsl:if">
							<xsl:attribute name="test">string-length($caption-temp)!=0</xsl:attribute>
							<xsl:element name="xsl:value-of">
								<xsl:attribute name="select">$caption-temp</xsl:attribute>
							</xsl:element>
							<xsl:element name="xsl:call-template">
								<xsl:attribute name="name">set-caption</xsl:attribute>
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">caption</xsl:attribute>
									<xsl:attribute name="select">''</xsl:attribute>
								</xsl:element>
							</xsl:element>
							<xsl:element name="xsl:text">
                    	&lt;br/&gt;
                    </xsl:element>
						</xsl:element>
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">$space-string</xsl:attribute>
						</xsl:element>
						<!--
                    <xsl:element name="xsl:value-of">
                        <xsl:attribute name="select">$space-string</xsl:attribute>
                    </xsl:element>
                    -->
					</xsl:element>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=2</xsl:attribute>
				<xsl:element name="xsl:text">
                &lt;td style="border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;
            </xsl:element>
				<xsl:element name="xsl:if">
					<xsl:attribute name="test">starts-with($normalized-string,'|')</xsl:attribute>
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select">substring-after($normalized-string,'|')</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:if">
					<xsl:attribute name="test">starts-with($normalized-string,'|')=false()</xsl:attribute>
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select">$normalized-string</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">set-table-status</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">status</xsl:attribute>
						<xsl:attribute name="select">3</xsl:attribute>
					</xsl:element>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">$table_status=3</xsl:attribute>
				<xsl:element name="xsl:choose">
					<xsl:element name="xsl:when">
						<xsl:attribute name="test">starts-with($normalized-string,'|')=true()</xsl:attribute>
						<xsl:element name="text">
                        &lt;/td&gt;
                    </xsl:element>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">set-table-status</xsl:attribute>
							<xsl:element name="xsl:with-param">
								<xsl:attribute name="name">status</xsl:attribute>
								<xsl:attribute name="select">2</xsl:attribute>
							</xsl:element>
						</xsl:element>
						<xsl:element name="xsl:if">
							<xsl:attribute name="test">string-length(substring-after($normalized-string,'|'))&gt;0</xsl:attribute>
							<xsl:element name="text">
                    		&lt;td style="border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;
                    	</xsl:element>
							<xsl:element name="xsl:value-of">
								<xsl:attribute name="select">substring-after($normalized-string,'|')</xsl:attribute>
							</xsl:element>
							<xsl:element name="xsl:call-template">
								<xsl:attribute name="name">set-table-status</xsl:attribute>
								<xsl:element name="xsl:with-param">
									<xsl:attribute name="name">status</xsl:attribute>
									<xsl:attribute name="select">3</xsl:attribute>
								</xsl:element>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:otherwise">
						<xsl:element name="xsl:value-of">
							<xsl:attribute name="select">$normalized-string</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
		<!-- xsl:template -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">display-headers</xsl:attribute>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">header-string</xsl:attribute>
			</xsl:element>
			<!--xsl:param-->
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">first-string</xsl:attribute>
				<xsl:attribute name="select">substring-before($header-string,'|')</xsl:attribute>
			</xsl:element>
			<!-- xsl:variable -->
			<xsl:element name="xsl:if">
				<xsl:attribute name="test">string-length($first-string)!=0</xsl:attribute>
				<xsl:element name="xsl:text">
            &lt;th style="text-align:center;border-color:#AAAAAA;border-style:solid;border-width:1px;"&gt;
          </xsl:element>
				<xsl:element name="xsl:value-of">
					<xsl:attribute name="select">normalize-space($first-string)</xsl:attribute>
				</xsl:element>
				<xsl:element name="xsl:text">
            &lt;/th&gt;
          </xsl:element>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">display-headers</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">header-string</xsl:attribute>
						<xsl:attribute name="select">substring-after($header-string,'|')</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<!-- xsl:call-template -->
			</xsl:element>
			<!-- xsl:if -->
		</xsl:element>
		<!-- xsl:template -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">save-header</xsl:attribute>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">header-string</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:call-template">
				<xsl:attribute name="name">set-table-header</xsl:attribute>
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">head</xsl:attribute>
					<xsl:attribute name="select">$header-string</xsl:attribute>
				</xsl:element>
			</xsl:element>
			<xsl:element name="xsl:call-template">
				<xsl:attribute name="name">set-table-status</xsl:attribute>
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">status</xsl:attribute>
					<xsl:attribute name="select">5</xsl:attribute>
				</xsl:element>
			</xsl:element>
		</xsl:element>
		<!-- template to stop a table, added by ws-5-9 -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">stop-table</xsl:attribute>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">table-status</xsl:attribute>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">get-table-status</xsl:attribute>
				</xsl:element>
			</xsl:element>
			<!-- end xsl:variable -->
			<!-- end table -->
			<xsl:element name="xsl:choose">
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=3</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
          </xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=2</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;/tr&gt;&lt;/table&gt;
          </xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=1</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;/table&gt;
          </xsl:element>
				</xsl:element>
			</xsl:element>
			<!--end xsl:choose -->
			<xsl:element name="xsl:call-template">
				<xsl:attribute name="name">set-table-status</xsl:attribute>
				<xsl:element name="xsl:with-param">
					<xsl:attribute name="name">status</xsl:attribute>
					<xsl:attribute name="select">0</xsl:attribute>
				</xsl:element>
			</xsl:element>
			<!--
      <xsl:element name="xsl:call-template">
        <xsl:attribute name="name">set-table-header</xsl:attribute>
        <xsl:element name="xsl:with-param">
          <xsl:attribute name="name">head</xsl:attribute>
          <xsl:attribute name="select">''</xsl:attribute>
        </xsl:element>
      </xsl:element>
      -->
		</xsl:element>
		<!-- end template stop-table -->
		<!-- template to process a br, added by ws-5-9 -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">process-br</xsl:attribute>
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">table-status</xsl:attribute>
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">get-table-status</xsl:attribute>
				</xsl:element>
			</xsl:element>
			<!-- end xsl:variable -->
			<!-- end table -->
			<xsl:element name="xsl:choose">
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=3</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;/td&gt;&lt;/tr&gt;
          </xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">set-table-status</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">status</xsl:attribute>
							<xsl:attribute name="select">1</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=2</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;/tr&gt;
          </xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">set-table-status</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">status</xsl:attribute>
							<xsl:attribute name="select">1</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=5</xsl:attribute>
					<xsl:element name="xsl:variable">
						<xsl:attribute name="name">header-temp</xsl:attribute>
						<xsl:element name="xsl:call-template">
							<xsl:attribute name="name">get-table-header</xsl:attribute>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">set-table-header</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">head</xsl:attribute>
							<xsl:element name="xsl:value-of">
								<xsl:attribute name="select">concat($header-temp,'|')</xsl:attribute>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">set-table-status</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">status</xsl:attribute>
							<xsl:attribute name="select">0</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=6</xsl:attribute>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">set-table-status</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">status</xsl:attribute>
							<xsl:attribute name="select">0</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">$table-status=0</xsl:attribute>
					<xsl:element name="xsl:text">
            &lt;br/&gt;
          </xsl:element>
				</xsl:element>
			</xsl:element>
			<!--end xsl:choose -->
		</xsl:element>
		<!-- end template process-br -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">replace-func</xsl:attribute>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">str</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">str-a</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">str-b</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:choose">
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">contains($str,$str-a)</xsl:attribute>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">replace-func</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">str</xsl:attribute>
							<xsl:attribute name="select">concat(substring-before($str,$str-a),$str-b,substring-after($str,$str-a))</xsl:attribute>
						</xsl:element>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">str-a</xsl:attribute>
							<xsl:attribute name="select">$str-a</xsl:attribute>
						</xsl:element>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">str-b</xsl:attribute>
							<xsl:attribute name="select">$str-b</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:otherwise">
					<xsl:element name="xsl:value-of">
						<xsl:attribute name="select">$str</xsl:attribute>
					</xsl:element>
				</xsl:element>
				<!--xsl:otherwise -->
			</xsl:element>
			<!-- xsl:choose -->
		</xsl:element>
		<!-- xsl:replace-func -->
		<xsl:element name="xsl:template">
			<xsl:attribute name="name">parse-col</xsl:attribute>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">target-string</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:param">
				<xsl:attribute name="name">is-begin-with-slide</xsl:attribute>
				<xsl:attribute name="select">0</xsl:attribute>
			</xsl:element>
			<xsl:element name="xsl:choose">
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">contains($target-string,'|')</xsl:attribute>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">display_cur_text</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">in_string</xsl:attribute>
							<xsl:element name="xsl:if">
								<xsl:attribute name="test">$is-begin-with-slide=1</xsl:attribute>
								<xsl:element name="xsl:value-of">
									<xsl:attribute name="select">concat('|',substring-before($target-string,'|'))</xsl:attribute>
								</xsl:element>
							</xsl:element>
							<xsl:element name="xsl:if">
								<xsl:attribute name="test">$is-begin-with-slide=0</xsl:attribute>
								<xsl:element name="xsl:value-of">
									<xsl:attribute name="select">substring-before($target-string,'|')</xsl:attribute>
								</xsl:element>
							</xsl:element>
						</xsl:element>
					</xsl:element>
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">parse-col</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">target-string</xsl:attribute>
							<xsl:attribute name="select">substring-after($target-string,'|')</xsl:attribute>
						</xsl:element>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">is-begin-with-slide</xsl:attribute>
							<xsl:attribute name="select">1</xsl:attribute>
						</xsl:element>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:otherwise">
					<xsl:element name="xsl:call-template">
						<xsl:attribute name="name">display_cur_text</xsl:attribute>
						<xsl:element name="xsl:with-param">
							<xsl:attribute name="name">in_string</xsl:attribute>
							<xsl:element name="xsl:if">
								<xsl:attribute name="test">$is-begin-with-slide=1</xsl:attribute>
								<xsl:element name="xsl:value-of">
									<xsl:attribute name="select">concat('|',$target-string)</xsl:attribute>
								</xsl:element>
							</xsl:element>
							<xsl:element name="xsl:if">
								<xsl:attribute name="test">$is-begin-with-slide=0</xsl:attribute>
								<xsl:element name="xsl:value-of">
									<xsl:attribute name="select">$target-string</xsl:attribute>
								</xsl:element>
							</xsl:element>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
		<!-- added by ws-5-6 stop -->
	</xsl:template>
</xsl:stylesheet>
